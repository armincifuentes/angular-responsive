// Generated by CoffeeScript 1.8.0
(function() {
  var responsive;

  responsive = angular.module("angular-responsive", []);

  responsive.service("Breakpoint", function() {
    return {
      w: 0,
      h: 0
    };
  });

  responsive.directive("responsive", function($window, Breakpoint) {
    return {
      restrict: "A",
      link: function(scope, element, attrs) {
        var w;
        w = angular.element($window);
        Breakpoint.w = w.width();
        Breakpoint.h = w.height();
        return w.bind("resize", function() {
          Breakpoint.w = w.width();
          Breakpoint.h = w.height();
          return scope.$digest();
        });
      }
    };
  });

  responsive.directive("minWidth", function(Breakpoint) {
    return {
      restrict: "A",
      link: function(scope, element, attrs) {
        return scope.$watch(function() {
          return Breakpoint.w;
        }, function(newWidth) {
          if (newWidth < parseInt(attrs.minWidth)) {
            element.hide();
          }
          if (newWidth > parseInt(attrs.minWidth)) {
            return element.show();
          }
        });
      }
    };
  });

  responsive.directive("maxWidth", function(Breakpoint) {
    return {
      restrict: "A",
      link: function(scope, element, attrs) {
        return scope.$watch(function() {
          return Breakpoint.w;
        }, function(newWidth) {
          if (newWidth > parseInt(attrs.maxWidth)) {
            element.hide();
          }
          if (newWidth < parseInt(attrs.maxWidth)) {
            return element.show();
          }
        });
      }
    };
  });

  responsive.directive("responsiveBooleans", function(Breakpoint, $parse) {
    return {
      restrict: "A",
      link: function(scope, element, attrs) {
        var checkConditions, conditions, parseConditions;
        conditions = $parse(attrs.responsiveBooleans)(scope);
        parseConditions = function() {
          return angular.forEach(conditions, function(val, key, obj) {
            return conditions[key] = {
              operation: val[0],
              value: val.substring(1)
            };
          });
        };
        checkConditions = function(value) {
          return angular.forEach(conditions, function(val, key) {
            switch (val.operation) {
              case '>':
                return scope[key] = value > val.value;
              case '<':
                return scope[key] = value < val.value;
              case '=':
                return scope[key] = value === val.value;
            }
          });
        };
        parseConditions();
        return scope.$watch(function() {
          return Breakpoint.w;
        }, function(newWidth) {
          return checkConditions(newWidth);
        });
      }
    };
  });

  responsive.directive("responsiveClasses", function(Breakpoint, $parse) {
    return {
      restrict: "A",
      link: function(scope, element, attrs) {
        var checkConditions, conditions, parseConditions;
        conditions = $parse(attrs.responsiveClasses)(scope);
        parseConditions = function() {
          return angular.forEach(conditions, function(val, key, obj) {
            return conditions[key] = {
              operation: val[0],
              value: val.substring(1)
            };
          });
        };
        checkConditions = function(value) {
          return angular.forEach(conditions, function(val, key) {
            switch (val.operation) {
              case '>':
                if (value > val.value) {
                  return element.addClass(key);
                } else {
                  return element.removeClass(key);
                }
                break;
              case '<':
                if (value < val.value) {
                  return element.addClass(key);
                } else {
                  return element.removeClass(key);
                }
                break;
              case '=':
                if (value === val.value) {
                  return element.addClass(key);
                } else {
                  return element.removeClass(key);
                }
            }
          });
        };
        parseConditions();
        return scope.$watch(function() {
          return Breakpoint.w;
        }, function(newWidth) {
          return checkConditions(newWidth);
        });
      }
    };
  });

}).call(this);
